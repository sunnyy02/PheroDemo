/**
 * This file is generated by Phero.
 * https://github.com/phero-hq/phero
 * Do not edit this file by hand. Changes will be disregarded next time it's generated.
 **/

/* eslint-disable */
/* prettier-disable */

import { Fetch, BasePheroClient, ParseResult, ValidationError } from "@phero/client";
export enum UserRole {
    ADMIN = "admin",
    USER = "user"
}
export interface User {
    name: string;
    age: number;
    role: UserRole;
}
export class UserRoleParser {
    static parse(data: any): ParseResult<UserRole> {
        const errors: ValidationError[] = [];
        let result: any;
        if (!["admin", "user"].includes(data)) {
            errors.push({
                path: "data",
                message: `not a member of enum`
            });
        }
        else
            result = data;
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as UserRole
        };
    }
}
export class UserParser {
    static parse(data: any): ParseResult<User> {
        const errors: ValidationError[] = [];
        let result: any;
        if (typeof data !== "object" || data === null) {
            errors.push({
                path: "data",
                message: `null or not an object`
            });
        }
        else {
            result = {};
            if (typeof data["name"] !== "string") {
                errors.push({
                    path: "data.name",
                    message: `not a string`
                });
            }
            else
                result["name"] = data["name"];
            if (typeof data["age"] !== "number") {
                errors.push({
                    path: "data.age",
                    message: `not a number`
                });
            }
            else if (isNaN(data["age"])) {
                errors.push({
                    path: "data.age",
                    message: `invalid number`
                });
            }
            else
                result["age"] = data["age"];
            if (!["admin", "user"].includes(data["role"])) {
                errors.push({
                    path: "data.role",
                    message: `not a member of enum`
                });
            }
            else
                result["role"] = data["role"];
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as User
        };
    }
}
function error_parser_helloWorldService(error: any): Error { if (error.name === "Error")
    return new Error(error.props.message);
else
    return new Error("Unknown Error"); }
function error_parser_userService(error: any): Error { if (error.name === "Error")
    return new Error(error.props.message);
else
    return new Error("Unknown Error"); }
export class PheroClient extends BasePheroClient {
    constructor(fetch: Fetch, url = "http://localhost:3030") { super(fetch, url); }
    helloWorldService = {
        helloWorld: async (name: string): Promise<string> => { return this.request<string>("helloWorldService", "helloWorld", { name }, error_parser_helloWorldService, (data: any): ParseResult<string> => {
            const errors: ValidationError[] = [];
            let result: any;
            if (typeof data !== "string") {
                errors.push({
                    path: "data",
                    message: `not a string`
                });
            }
            else
                result = data;
            if (errors.length) {
                return {
                    ok: false,
                    errors
                };
            }
            return {
                ok: true,
                result: result as string
            };
        }); }
    };
    userService = {
        getAllUsers: async (): Promise<User[]> => { return this.request<User[]>("userService", "getAllUsers", {}, error_parser_userService, (data: any): ParseResult<User[]> => {
            const errors: ValidationError[] = [];
            let result: any;
            if (!Array.isArray(data)) {
                errors.push({
                    path: "data",
                    message: `not an array`
                });
            }
            else {
                result = [];
                for (let it_0 = 0; it_0 < data.length; it_0++) {
                    const parseResult = UserParser.parse(data[it_0]);
                    if (!parseResult.ok) {
                        errors.push({
                            path: `data[${it_0}]`,
                            message: `not a domain.v_1_0_0.User`
                        });
                    }
                    else
                        result[it_0] = parseResult.result;
                }
            }
            if (errors.length) {
                return {
                    ok: false,
                    errors
                };
            }
            return {
                ok: true,
                result: result as User[]
            };
        }); },
        helloWorld: async (name: string): Promise<string> => { return this.request<string>("userService", "helloWorld", { name }, error_parser_userService, (data: any): ParseResult<string> => {
            const errors: ValidationError[] = [];
            let result: any;
            if (typeof data !== "string") {
                errors.push({
                    path: "data",
                    message: `not a string`
                });
            }
            else
                result = data;
            if (errors.length) {
                return {
                    ok: false,
                    errors
                };
            }
            return {
                ok: true,
                result: result as string
            };
        }); }
    };
}
